#!/bin/bash
#
# gopro-format - Prepare an SD card for GoPro Hero13
#
# Usage: gopro-format [-b] [-f] [-c [LABEL]] [-l] [device]
#   -b           Check for bad blocks before formatting
#   -f           Check for fake/counterfeit flash (f3probe)
#   -c [LABEL]   Check when a card was formatted (reads card label or specify one)
#   -l           List full format history
#   device       Block device (e.g. /dev/sda). Auto-detected if omitted.

set -euo pipefail

BAD_BLOCKS=0
FAKE_CHECK=0
CHECK_MODE=0
CHECK_LABEL=""
LIST_MODE=0
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
LOG_FILE="$SCRIPT_DIR/gopro-format.log"

usage() {
    echo "Usage: $(basename "$0") [-b] [-f] [-c [LABEL]] [-l] [device]"
    echo "  -b           Check for bad blocks before formatting"
    echo "  -f           Check for fake/counterfeit flash (f3probe)"
    echo "  -c [LABEL]   Check when a card was formatted (reads card label or specify one)"
    echo "  -l           List full format history"
    echo "  device       Block device (e.g. /dev/sda). Auto-detected if omitted."
    exit 1
}

# --- Manual argument parsing (getopts can't handle optional args well) ---
while [[ $# -gt 0 ]]; do
    case "$1" in
        -b)
            BAD_BLOCKS=1
            shift
            ;;
        -f)
            FAKE_CHECK=1
            shift
            ;;
        -c)
            CHECK_MODE=1
            shift
            # If next arg exists and doesn't start with - and isn't a block device path, treat as label
            if [[ $# -gt 0 && "$1" != -* && "$1" != /dev/* ]]; then
                CHECK_LABEL="$1"
                shift
            fi
            ;;
        -l)
            LIST_MODE=1
            shift
            ;;
        -h|--help)
            usage
            ;;
        -*)
            echo "Unknown option: $1"
            usage
            ;;
        *)
            # Positional arg — device
            DEV="$1"
            shift
            ;;
    esac
done

# --- Handle -l: list full format history ---
if [[ "$LIST_MODE" -eq 1 ]]; then
    if [[ ! -f "$LOG_FILE" ]]; then
        echo "No format history found."
    else
        echo "Format history ($LOG_FILE):"
        echo ""
        cat "$LOG_FILE"
    fi
    exit 0
fi

# --- Handle -c: check/lookup mode ---
if [[ "$CHECK_MODE" -eq 1 ]]; then
    if [[ -n "$CHECK_LABEL" ]]; then
        # Look up the given label in the log
        if [[ ! -f "$LOG_FILE" ]]; then
            echo "No format history found."
            exit 0
        fi
        MATCHES=$(grep "$CHECK_LABEL" "$LOG_FILE" || true)
        if [[ -z "$MATCHES" ]]; then
            echo "No entries found for label: $CHECK_LABEL"
        else
            echo "Entries for $CHECK_LABEL:"
            echo ""
            echo "$MATCHES"
        fi
    else
        # Auto-detect card and read its label
        # Need root to detect devices reliably
        if [[ $EUID -ne 0 ]]; then
            echo "ERROR: Must run as root to auto-detect card (use sudo), or specify a label: -c LABEL"
            exit 1
        fi

        # --- Find device (same auto-detect logic) ---
        if [[ -z "${DEV:-}" ]]; then
            CANDIDATES=()
            for d in /sys/block/sd* /sys/block/mmcblk*; do
                [[ -e "$d" ]] || continue
                devname="/dev/$(basename "$d")"
                removable=$(cat "$d/removable" 2>/dev/null || echo 0)
                if [[ "$removable" == "1" ]] || [[ "$(basename "$d")" == mmcblk* ]]; then
                    CANDIDATES+=("$devname")
                fi
            done

            if [[ ${#CANDIDATES[@]} -eq 0 ]]; then
                echo "ERROR: No removable SD card device found."
                exit 1
            elif [[ ${#CANDIDATES[@]} -eq 1 ]]; then
                DEV="${CANDIDATES[0]}"
            else
                echo "Multiple removable devices found:"
                for i in "${!CANDIDATES[@]}"; do
                    echo "  [$i] ${CANDIDATES[$i]}"
                done
                read -rp "Select device number: " sel
                DEV="${CANDIDATES[$sel]}"
            fi
        fi

        # Read label from the device's first partition
        if [[ "$DEV" == *mmcblk* ]]; then
            PART="${DEV}p1"
        else
            PART="${DEV}1"
        fi

        CARD_LABEL=$(lsblk -ndo LABEL "$PART" 2>/dev/null || true)
        if [[ -z "$CARD_LABEL" ]]; then
            echo "Could not read label from $PART"
            exit 1
        fi

        echo "Card label: $CARD_LABEL"
        echo ""

        if [[ ! -f "$LOG_FILE" ]]; then
            echo "No format history found."
            exit 0
        fi

        MATCHES=$(grep "$CARD_LABEL" "$LOG_FILE" || true)
        if [[ -z "$MATCHES" ]]; then
            echo "No entries found for label: $CARD_LABEL"
        else
            echo "$MATCHES"
        fi
    fi
    exit 0
fi

# --- Must be root ---
if [[ $EUID -ne 0 ]]; then
    echo "ERROR: Must run as root (use sudo)."
    exit 1
fi

# --- Find device ---
if [[ -z "${DEV:-}" ]]; then
    # Auto-detect: look for removable SD-card-sized devices
    CANDIDATES=()
    for d in /sys/block/sd* /sys/block/mmcblk*; do
        [[ -e "$d" ]] || continue
        devname="/dev/$(basename "$d")"
        removable=$(cat "$d/removable" 2>/dev/null || echo 0)
        # Accept removable disks, or mmcblk devices (always removable media)
        if [[ "$removable" == "1" ]] || [[ "$(basename "$d")" == mmcblk* ]]; then
            CANDIDATES+=("$devname")
        fi
    done

    if [[ ${#CANDIDATES[@]} -eq 0 ]]; then
        echo "ERROR: No removable SD card device found."
        echo "Insert the card or specify the device manually: $(basename "$0") /dev/sdX"
        exit 1
    elif [[ ${#CANDIDATES[@]} -eq 1 ]]; then
        DEV="${CANDIDATES[0]}"
    else
        echo "Multiple removable devices found:"
        for i in "${!CANDIDATES[@]}"; do
            echo "  [$i] ${CANDIDATES[$i]}"
        done
        read -rp "Select device number: " sel
        DEV="${CANDIDATES[$sel]}"
    fi
fi

# Strip trailing partition number so we always have the whole-disk device
DEV="${DEV%[0-9]}"
DEV="${DEV%p}"  # handle mmcblk0p1 -> mmcblk0

if [[ ! -b "$DEV" ]]; then
    echo "ERROR: $DEV is not a block device."
    exit 1
fi

# --- Generate dynamic label ---
TODAY=$(date +%y%m%d)
SEQ=1
if [[ -f "$LOG_FILE" ]]; then
    COUNT=$(grep -c "$TODAY" "$LOG_FILE" || true)
    SEQ=$((COUNT + 1))
fi
LABEL="GP${TODAY}$(printf '%02d' "$SEQ")"

# --- Step 1: Display device info for confirmation ---
echo "============================================"
echo "  SD Card Device: $DEV"
echo "  Label: $LABEL"
echo "============================================"
echo ""
lsblk -o NAME,SIZE,TYPE,FSTYPE,LABEL,MODEL,TRAN "$DEV"
echo ""
echo ">> Partition table:"
parted "$DEV" print free 2>/dev/null || echo "   (no partition table found)"
echo ""
echo "WARNING: ALL DATA ON $DEV WILL BE DESTROYED."
read -rp "Type YES to continue: " confirm
if [[ "$confirm" != "YES" ]]; then
    echo "Aborted."
    exit 1
fi

# Unmount any mounted partitions
echo ""
echo ">> Unmounting any mounted partitions..."
for part in "${DEV}"*; do
    if mountpoint -q "$part" 2>/dev/null || mount | grep -q "^$part "; then
        umount "$part" && echo "   Unmounted $part"
    fi
done

# --- Step 2 (optional): Bad block check ---
if [[ "$BAD_BLOCKS" -eq 1 ]]; then
    echo ""
    echo ">> Checking for bad blocks (destructive write test)..."
    echo "   This writes test patterns to every sector and verifies them."
    BB_OUT=$(mktemp)
    badblocks -wsv -o "$BB_OUT" "$DEV"
    BB_COUNT=$(wc -l < "$BB_OUT")
    if [[ "$BB_COUNT" -gt 0 ]]; then
        echo ""
        echo "   WARNING: $BB_COUNT bad block(s) found!"
        echo "   SD cards use internal wear-leveling — bad blocks surfacing"
        echo "   to the OS means the card's controller has exhausted its"
        echo "   spare sectors. This card should be REPLACED."
        cat "$BB_OUT"
        rm -f "$BB_OUT"
        read -rp "   Continue formatting anyway? (YES/no): " bb_confirm
        if [[ "$bb_confirm" != "YES" ]]; then
            echo "Aborted."
            exit 1
        fi
    else
        echo "   No bad blocks found."
        rm -f "$BB_OUT"
    fi
fi

# --- Step 2b (optional): Fake flash check ---
if [[ "$FAKE_CHECK" -eq 1 ]]; then
    echo ""
    echo ">> Checking for fake/counterfeit flash (f3probe)..."
    echo "   This probes the device to detect cards that misreport their capacity."
    if ! command -v f3probe &>/dev/null; then
        echo "   ERROR: f3probe not found. Install with: sudo apt install f3"
        exit 1
    fi
    F3_OUT=$(f3probe --destructive "$DEV" 2>&1) || true
    echo "$F3_OUT"
    if echo "$F3_OUT" | grep -qi "counterfeit\|fake"; then
        echo ""
        echo "   WARNING: This card appears to be COUNTERFEIT!"
        echo "   The reported capacity does not match the real storage."
        echo "   This card should be REPLACED."
        read -rp "   Continue formatting anyway? (YES/no): " f3_confirm
        if [[ "$f3_confirm" != "YES" ]]; then
            echo "Aborted."
            exit 1
        fi
    else
        echo "   Card appears genuine."
    fi
fi

# --- Step 3: Write msdos partition table + single partition ---
echo ""
echo ">> Creating msdos partition table on $DEV..."

# Determine partition device name (sda -> sda1, mmcblk0 -> mmcblk0p1)
if [[ "$DEV" == *mmcblk* ]]; then
    PART="${DEV}p1"
else
    PART="${DEV}1"
fi

parted -s "$DEV" mklabel msdos
parted -s "$DEV" mkpart primary 1MiB 100%

# Let kernel pick up the new table
partprobe "$DEV"
sleep 1

# --- Step 4: Format exFAT with dynamic label ---
echo ">> Formatting ${PART} as exFAT (label: $LABEL)..."
mkfs.exfat -L "$LABEL" "$PART"

# --- Step 5: Log the format ---
DEV_SIZE=$(lsblk -ndo SIZE "$DEV" | tr -d ' ')
DEV_MODEL=$(lsblk -ndo MODEL "$DEV" | sed 's/  */ /g; s/^ //; s/ $//')
TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
echo "$TIMESTAMP | $LABEL | $DEV | $DEV_SIZE | $DEV_MODEL" >> "$LOG_FILE"

echo ""
echo "============================================"
echo "  Done. SD card is ready for GoPro Hero13."
echo "  Label: $LABEL"
echo "============================================"
lsblk -o NAME,SIZE,TYPE,FSTYPE,LABEL "$DEV"
